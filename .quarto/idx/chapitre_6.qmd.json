{"title":"Outils de visualisation graphique","markdown":{"headingText":"Outils de visualisation graphique","containsRefs":false,"markdown":"\n## Point d'observation: historique de la visualisation graphique\nUne fois les données collectées, nettoyées, traitées et analysées, une partie centrale du travail d'un scientifique de données est de faire parler les résultats de ses tests empiriques. Il s'agit alors de trouver la meilleure manière de rendre l'information digeste pour les experts et initiés de votre discipline académique ou pour le grand public. La visualisation graphique des données est donc centrale afin de vulgariser les résultats d'une recherche empirique.\n\nCette volonté de vulgariser des données à l'aide d'image ne date pas d'hier. En effet, le \n\n*Milestones Project*.  \n\n*A History of Data Visualization and Graphic Communication*\n\nLéger retour en arrière pour comprendre l'évolution de la visualisation graphique.\n\nPremier âge d'or de la visualisation graphique: 18e siècle\n\n\n\n\n\n## Arpentage et choix éditorial:\n\nIl existe plusieurs outils de visualisation qui répondent à des besoins différents.\n\n\n\nNous nous concentrerons sur les outils respectant au mieux les critères de sélections établis au chapitre 1.\n\n\nBien entendu, les logiciels tels que *Tableau*, *Stata*, *SPSS*, *SAS* ou encore *Excel* peuvent s'avérer très pertinents selon vos exigences spécifiques. Ils sont souvent dotés d'une interface utilisateur intuitive, facilitant ainsi leur utilisation pour une variété de tâches. Toutefois, ils pourraient présenter certaines limites en matière de personnalisation des analyses et des visualisations. Par ailleurs, bien que certains de ces outils offrent une grande flexibilité, leur coût peut être considérable. Si votre institution possède une licence pour ces logiciels, il demeure judicieux de les utiliser. \n\nIl existe des outils gratuits et offrant un plus grand contrôle et offre plus de flexibilité que les logiciels de visualisation de données. Les logiciels. Programmation possible de personnaliser les graphiques à l'infini. \n\nBien que ce livre prend position en faveur de *R* comme présenté au chapitre 2, il est important de reconnaître les capacités de *Python* dans le domaine de la visualisation graphique. *Python* est un langage de programmation généraliste et est répandu dans la majorité des universités et sur le marché du travail [@ozgurMatLabVsPython2017]. Matplotlib, Seaborn et Plotly sont des *packages* de  \n\n*R* est spécialisé en statistiques et scientific research and academia, analytical power of R is virtually unmatched.[@ozgurMatLabVsPython2017].  \n\n\n\nhttps://www.r-project.org/about.html\n\n\n## Manuel d'instruction: La visualisation graphique avec R\nLorsque vous souhaitez créer des graphiques en R, les options abondent. De multiples *packages* ont été développés dans le but de visualiser des données. Heureusement, les choix diminuent lorsque l'on regarde ce qui est le plus utilisé dans la communauté. L'objectif n'est pas simplement de présenter les *packages* les plus courrants parce qu'ils sont les plus communs. Les *packages* les plus utilisés représentent des outils qui ont été grandement vérifiés et améliorés par la communauté en ligne, dont la documentation est abondante et pour lesquels les ressources d'aide en ligne sont innombrables. \n\n### Pour les analyses descriptives\n\n#### Base R\nLe *Base R* est le langage de base de R et il permet de faire de nombreuses manipulations statistiques sans avoir à installer de *packages* au préalable. Le *Base R* permet notamment de produire des graphiques rapidement. Cela peut être utile pour visualiser la distribution d'une variable ou pour regarder la relation entre deux d'entre elles, par exemple. Pour produire un graphique avec le langage de base R, il suffit de faire appel à la fonction *plot()*. Avec la fonction *plot()*, le codeur peut visualiser la distribution d'une variable seule en spécifiant l'axe des *x* dans cette dernière. Le codeur peut également visualiser la relation entre deux variables en spécifiant à l'intérieur de la fonction celles qui composeront les axes des *x* et des *y* du graphique. Les fonctions *barplot(), hist()* ou *boxplot()* disponibles dans le *Base R* permettent de spécifier le style de graphique souhaité, qu'on veuille représenter nos données sous forme de diagramme à barre, d'histogramme ou de diagramme en boîtes [@kabacoff22, p. 119-132].\n\nAlors qu'un peu tout peut être fait avec le *Base R*, ce langage demeure élémentaire; il est difficile d'innover dans la visualisation ou même de produire des graphiques plus sophistiqués. Le *Base R* peut sembler plus simple pour l'exploration de données ou pour produire des graphiques de base rapidement, mais ce langage devient rapidement complexe lorsqu'on cherche à améliorer l'esthétique de son graphique ou à visualiser des relations entre plusieurs variables, ce que *lattice* et *ggplot2* permettent plus facilement[@wickham09, p. 3-4].\n\n#### Lattice\nDéveloppé par Deepayan Sarkar, lattice cherche à faciliter la visualisation de graphique en facettes. Plus précisément, ce package vise à améliorer les graphiques du Base R en fournissant de meilleures options de graphisme par défaut pour visualiser des relations multivariées. Ce package est donc intéressant pour les chercheurs et les codeurs voulant présenter graphiquement la relation entre plus de deux variables (Kabacoff, 2022, p. 373‑377; Sarkar, 2008, 2023). Pour produire un graphique de base avec Lattice, le package lattice doit préalablement être installé dans la bibliothèque de packages du codeur et chargé dans sa session au début de son code (voir annexe). Par la suite, le codeur doit spécifier le type de graphique souhaité avec la fonction appropriée3. Une fois la fonction choisie, il doit spécifier par une formule les variables x et y ainsi que la troisième variable à contrôler et à visualiser en facettes (graph_type(formula | variable en facettes, data=)).\n\nCependant, le package lattice a pour désavantage d’avoir un modèle formel (une grammaire de graphique) moins compréhensible et intuitif que celui de ggplot2 lorsque vient le temps d’améliorer l’esthétisme des graphiques. De plus, sa plus faible popularité fait en sorte que ce package demeure moins développé par la communauté de codeurs de R que ne l’est ggplot2. Nous examinons plus en détail la grammaire de graphique de ce dernier package ainsi que ses avantages et inconvénients dans la prochaine section (Kabacoff, 2022, p. 373‑377 et 390; Wickham, 2009, p. 6).\n\n#### Ggplot 2\nDéveloppé principalement par Hadley Wickham, *ggplot2* est un *package R* faisant partie de la collection de *packages* de *tidyverse*. Ainsi, *Ggplot2* peut être utilisé avec les autres *packages* centraux de *tidyverse* ce qui limite de potentiels conflits entre les fonctions de *packages* qui puissent être incompatibles avec *ggplot2*. Par exemple, le *package dplyr* de *tidyverse* est très utile pour analyser, organiser et préparer vos données à visualiser avec *ggplot2* [@wickham_etal19; @wickham_etal23, p. 30].\n\nLe principal avantage de *ggplot2* reste sa grammaire qui permet à l'utilisateur de rendre ses graphiques beaucoup plus visuellement attrayants en facilitant la personnalisation esthétique. Ceci permet de pousser l'esthétisme de vos graphiques à un très haut niveau par rapport aux autres *packages* de visualisation graphique disponibles en R. Les graphiques *ggplot2* se construisent couche par couche, soit par l'ajout des différents éléments du graphique au fur et à mesure dans le code du graphique à construire.\n\n\n### Pour visualiser les régressions\n\nLorsque l'on souhaite aller au-delà des analyses descriptives, il devient pertinent de recourir aux modèles de régression. Si la fonction `summary(model)` offre une manière simple et rapide d'obtenir un aperçu d'un modèle, ses limites se manifestent lorsqu'il s'agit de visualiser et de comparer plusieurs modèles ou encore de les présenter de manière claire à une équipe ou dans le cadre d'une publication scientifique. La section suivante du chapitre introduira divers outils qui facilitent la visualisation, la comparaison et la présentation efficace de nos modèles de régression.\n\n:::::: {.callout-note}\nLe manuel d'instructions de cette section restera volontairement bref et concis en raison de l'abondante documentation déjà existante sur ces outils. L'objectif ici est de les centraliser en un seul endroit.\n:::\n\n#### Le package `stargazer`\n\nLe package `stargazer` est un package qui permet de générer des tableaux de régression de manière simple et efficace. Selon son auteur, Marek Hlavac, ce package excelle dans trois aspects : sa facilité d'utilisation, la diversité des modèles supportés et son esthétisme [@hlavac22]. Bien que nous soyons partiellement d'accord avec ces propos et que `stargazer` réponde effectivement à ces trois aspects, nous estimons que le package `modelsummary` (@sec-model-summary) surpasse `stargazer` dans chacun de ces domaines.\n\nVoici une façon standard d'utiliser `stargazer` pour créer un tableau de deux modèles de régression:\n\n```{r}\n#| code-overflow: wrap\n# Il faut premièrement installer et importer le package stargazer si ce n'est pas déjà fait.\n# install.packages(\"stargazer\") # installer\n\nlibrary(stargazer) # importer le package\n\n## Créer deux modèles de régression\nmod_lm <- lm(mpg ~ hp + wt, data = mtcars)\nmod_glm <- glm(vs ~ hp + wt + drat, data = mtcars, family = binomial())\n\nstargazer(mod_lm, mod_glm, type = \"text\", title = \"Tableau de régression des modèles\")\n```\n\nAlors que cette sortie texte est intéressante afin de rapidement visualiser différents modèles de régression, `stargazer` offre également l'option de transformer ces modèles en `latex` avec l'argument `type`:\n\n```{r}\nstargazer(mod_lm, mod_glm, type = \"latex\", title = \"Tableau de régression des modèles\")\n```\n\nAlors que cette sortie est moins compréhensible qu'avec `type = \"text\"`, cette sortie a l'avantage de pouvoir être copiée et collée dans un fichier .tex et ainsi présenter le tableau dans un article par exemple. Une autre option est possible avec `type = \"html\"` afin d'inclure la table de régression dans un code html:\n\n```{r}\nstargazer(mod_lm, mod_glm, type = \"html\", title = \"Tableau de régression des modèles\")\n```\n\nBien qu'il existe des milliers de façons de personnaliser son tableau de régression avec `stargazer`, nous vous invitons à consulter la documentation du package [@hlavac22] ainsi que différents blogs en ligne afin de personnaliser votre tableau comme vous le voulez.\n\n#### `modelsummary` {#sec-model-summary}\n\nLe package `modelsummary` [@arel-bundock22a], développé dans le même but que `stargazer`, est une nette amélioration au package `stargazer` selon l'avis des auteurs du chapitre: il est encore plus facile d'utilisation, supporte une grande variété de modèles et se connecte à divers autres outils afin de contrôler l'esthétisme de son résultat. De plus, la documentation officielle du package est beaucoup plus abondante et claire. Finalement, le package est plus intuitif à utiliser.\n\nTout comme `stargazer`, il faut commencer en créant un modèle de régression. Puis, il suffit d'inclure les modèles dans la fonction `modelsummary`:\n\n```{r}\n#| code-overflow: wrap\n# Il faut premièrement installer et importer le package modelsummary si ce n'est pas déjà fait.\n# install.packages(\"modelsummary\") # installer\n\nlibrary(modelsummary) # importer le package\n\n## Créer deux modèles de régression\nmod_lm <- lm(mpg ~ hp + wt, data = mtcars)\nmod_glm <- glm(vs ~ hp + wt + drat, data = mtcars, family = binomial())\n\n## Utiliser modelsummary pour créer un tableau de deux modèles de régression\nmodelsummary(list(\"Model 1\" = mod_lm, \"Model 2\" = mod_glm), output = \"markdown\")\n```\n\nTout comme `stargazer`, `modelsummary` offre également l'option de transformer ces modèles en `latex` ou `html` avec l'argument `output`:\n\n```{r}\nmsummary(list(\"Model 1\" = mod_lm, \"Model 2\" = mod_glm), output = \"latex\")\nmsummary(list(\"Model 1\" = mod_lm, \"Model 2\" = mod_glm), output = \"html\")\n```\n\nNous vous invitons à consulter la documentation du package `modelsummary` [@arel-bundock22a] pour plus d'informations sur la personnalisation de vos tableaux de régression.\n\n#### `marginaleffects`\n\n[@arel-bundock]\n\n### Aller plus loin: La visualisation interactive des données\n\nSi jusqu'à présent la visualisation des données a été présentée comme une étape permettant de présenter les résultats de recherches, il est également possible de considérer la visualisation comme une utile au processus d'exploration des données comportants de nombreuses dimensions (autres façons de le dire peut-être?). En effet, les formes de visualisations dites interactives permettant d'explorer et même d'analyser les données à même notre graphique ou notre tableau. Cela contribue à mieux comprendre la structures des données, à inspecter plus rapidement ces dernières et même susciter des questions de recherches peut-être omises autrement (citer Sievert, 2020). \n\n- ggplotly et plotly\n- Tableaux interactifs? fonctions kable() et kableExtra du package knitr\n- Shiny Apps\n\n\n\n\n<!--\n```{=html}\n\n## Réflexion théorique\n\n### Les options disponibles\n\nLorsque vous souhaitez créer des graphiques en R, les options abondent. De multiples *packages* ont été développés dans le but de visualiser des données. Heureusement, les choix diminuent lorsque l'on regarde ce qui est le plus utilisé dans la communauté. L'objectif n'est pas simplement de présenter les *packages* les plus courrants parce qu'ils sont les plus communs. Les *packages* les plus utilisés représentent des outils qui ont été grandement vérifiés et améliorés par la communauté en ligne, dont la documentation est abondante et pour lesquels les ressources d'aide en ligne sont innombrables. \n\nTrois options vous sont présentées: Base R, Lattice et ggplot2. Les avantages et inconvénients respectifs de ces trois approches pour la création de graphiques sont explicités dans les sections suivantes.\n\n#### Avantages et inconvénients de Base R\n\nBase R est le logiciel de base qui contient le langage de programmation R. Lorsque R Studio est installé sur un ordinateur, il est toujours possible d'utiliser le langage de base de R pour coder sans même avoir à installer des *packages*. Base R permet donc de produire des graphiques rapidement sans avoir à installer quoi que ce soit. \n\n\nPour produire un graphique avec ce langage de base, il suffit de faire appel à la fonction *plot()* dans laquelle il est spécifié un x et y à partir d'une base de données et un graphiques est déjà créé. Les fonctions *barplot(), hist()* ou *boxplot()* ajoutés au graphiques permettent de spécifier le style de visualisation souhaitée.\n\n## Réflexion théorique\n\n\nAlors qu'un peu tout peut être fait avec Base R, ce langage demeure élémentaire; il est difficile d'innover dans la visualisation ou même de produire des graphiques moindrement sophistiqués. Base R peut sembler plus simple pour l'exploration de données ou pour produire des graphiques de base rapidement, mais ce langage devient vite complexe.\n\n**Exemple Base R**\n\n#### Avantages et inconvénients de Lattice\n\nDéveloppé par Deepayan Sarkar, Lattice est un système graphique qui implémente spécifiquement l'idée des graphiques à facettes, qui a été initialement développée pour des langages informatique comme *S* et *S-Plus* [sarkar23]. Ce langage vise à améliorer les graphiques de Base R en fournissant de meilleures valeurs par défaut et la possibilité d'afficher facilement des relations multivariées. Le package prend en charge la création de graphiques en treillis (afficher une variable ou la relation entre les variables, conditionné par une ou plusieurs autres variables). \n\nPour produire un grpahique de base avec Lattice, le *package lattice* doit préalablement être installé sur l'ordinateur et chargé dans la session d'utilisation. Il suffit ensuite de spécifier un type de graphique, la formule qui lie x et y ainsi que les données qui serviront à produire le graphique (*graph_type(formula, data=)*).\n\nIl est, de manière générale, plus complexe de se familiariser avec ce langage qui est moins instinctif et moins populaire; la communauté en ligne est donc moins développée.\n\n**Exemple Lattice**\n\n#### Avantages et inconvénients de ggplot2\n\nDéveloppé principalement par Hadley Wickham, **ggplot2** est un  *package R* faisant partie de la collection de *packages* de **tidyverse**. L'utilisation de **ggplot2** permet donc une adéquation avec d'autres *packages* centraux au développement de la visualisation des données et des analyses statistiques, comme  **dplyr** [@wickham_etal19]. Lorsque la **tidyverse** est utilisée de l'importation des données à leur visualisation graphique, la cohérence entre les *packages* présente l'avantage d'assurer qu'il n'y a pas de conflits entre les fonctions, et donc, réduit les erreurs introduites potentiellement. \n\n\nAvantages: tidyverse, beauté et possibilités infinies (on peut les animer!!!), beaux résultats même pour les débutants, rapidité pour l'exploration de données, facettes\n          - Inconvénients: complexité potentielle, package extérieur, courbe d'apprentissage plus élevée\n\n\n# Plan\n- Question: Comment opimiser l'intelligibilité des données?\n      - Communication et vulgarisation **Question : Est-ce qu'il nous faut nécessairement une question de recherche dans ce chapitre qui est plus technique**\n      \n- Réflexion théorique:\n      - Différentes options disponibles (base R, lattice et ggplot2)\n      - Avantages et inconvénients de ggplot2\n          - Avantages: tidyverse, beauté et possibilités infinies (on peut les animer!!!), beaux résultats même pour les débutants, rapidité pour l'exploration de données, facettes\n          - Inconvénients: complexité potentielle, package extérieur, Base R est toujours là, courbe d'apprentissage plus élevée **Montrer un exemple de graphique construit layer par layer (couche par couche)**\n      - Comparaison\n          - Base R: la fonction plot() de base ou avec arguments, les fonctions barplot(), hist(), boxplot(), les grids. Base R peut sembler plus siple pour l'exploration de données, mais de vient vite plus complexe (même pour visualiser avec grid).\n          - Lattice: explication du package densityplot(), splom(), xyplot()\n- Réflexion méthodologique :\n      - Comment utiliser ggplot2:\n          - Grammar of graphics: créer toutes sortes de graphiques à partir de quelques composants: data, geom, coordinate system et plot\n          - Aesthetic propreties de base: size, color, emplacements de x et y\n          - Transformation de la base de données d'origine directement dans le graphique (ex: stat)\n      - Exemples et fonctionnalités\n          - Graphiques les plus communs avec variables discrètes ou continues\n          - Cartes\n          - Visualisation de 3 variables\n          - Visualisation des marges d'erreur, juste spécifier que l'option est possible\n– Trucs et astuces :\n      - ggplot2 cheat sheet\n      - Pleins d'idées de visualisation en ligne et de codes adaptables disponibles\n      - Retour sur la communication des données: choix du graphique en fonction des données et de l'objectif de communication\n    \n    \nOutils pour les schémas\n\nIl peut être nécessaire au cours d’un processus scientifique, une présentation, autre de faire des schémas.\n\nToujours pertinent de faire un croquis à la main, mais lorsque vient le temps de le rendre propre, présentable quels outils s’offrent à nous?\n\nMoody, D. (2007). What Makes a Good Diagram? Improving the Cognitive Effectiveness of Diagrams in IS Development. In W. Wojtkowski, W. G. Wojtkowski, J. Zupancic, G. Magyar, & G. Knapp (Eds.), Advances in Information Systems Development (pp. 481–492). Springer US.\n\nLarkin, J. H., & Simon, H. A. (1987). Why a Diagram is (Sometimes) Worth Ten Thousand Words. Cognitive Science, 11(1), 65–100.\n\nSuttorp, M. M., Siegerink, B., Jager, K. J., Zoccali, C., & Dekker, F. W. (2015). Graphical presentation of confounding in directed acyclic graphs. Nephrology Dialysis Transplantation, 30(9), 1418–1423.\n\nDiagrams.net (anciennement Draw.io)\nthe best free diagram and flowchart app\nLucidchart\n\nMiro   \n      \n      -->\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","citeproc":true,"output-file":"chapitre_6.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"fr_FR","fig-responsive":true,"quarto-version":"1.5.57","bibliography":["livre-outils.bib"],"csl":"https://www.zotero.org/styles/apa","citations-hover":true,"editor":"visual","theme":{"light":"pulse","dark":"slate"},"code-copy":true,"author-meta":"Chaire de leadership en enseignement des sciences sociales numériques (CLESSN)","callout-appearance":"simple"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}